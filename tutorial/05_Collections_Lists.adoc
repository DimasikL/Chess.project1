= Коллекции, итераторы, списки

Здесь мы начинаем рассматривать библиотеку коллекций Java. 

== Основные понятия

Библиотека коллекций строится на трёх видах кирпичей:

* *интерфейсы* `interface` определяют, что именно умеет делать тот или иной объект, но обычно ничего не говорят о том, как он это делает
* *абстрактные классы* `abstract class` содержат так называемую частичную реализацию объекта; в библиотеке коллекций они, как правило, реализуют все необходимые методы через несколько базовых
* *классы* `class` отвечают на вопрос о том, какие именно данные хранит объект и как именно он осуществляет те или иные операции

В прикладном коде интерфейсы обычно используются для определения типов переменных, параметров, полей, результатов методов; классы -- для создания объектов при вызове их конструкторов. Абстрактные классы в прикладном коде используются сравнительно редко, они позволяют за короткое время написать свою реализацию коллекции, если это потребовалось.

Для описания отношений вида *подтип*, *подвид* используется концепция *наследования*. В объектно-ориентированном программировании ситуация, когда класс (интерфейс) Б является *наследником* класса (интерфейса) А, означает, что:

* по смыслу объект типа Б является разновидностью объекта типа А
* объект типа Б можно употреблять везде, где нужен тип А
* объект типа Б содержит все данные, которые есть в объекте типа А (и, возможно, какие-либо другие)
* на объекте типа Б можно вызывать все методы, которые можно вызывать на объекте типа А (и, возможно, какие-либо другие)

Сокращённо говорят, что "public inheritance means IS A", или "открытое наследование означает ЭТО ЕСТЬ". В Java любое наследование считается открытым (в отличие от, например, С\+\+). Кроме этого, с наследованием связано ещё два специальных слова:

* про класс Б можно сказать, что он *расширяет* класс А или *реализует* интерфейс А (в обоих случаях он является наследником А)
* про интерфейс Б можно сказать, что он *расширяет* интерфейс А (и опять-таки это синоним слова "наследник")
* интерфейс Б никогда не может являться наследником класса А (запрещено правилами Java).

== Иерерхия коллекций

Коллекции Java образуют иерархию наследования. С ней можно ознакомиться, например, здесь: https://en.wikipedia.org/wiki/Java_collections_framework. Подобное изображение иерархий распространено среди программистов; в них наследник всегда рисуется ниже своего базового класса (интерфейса) и соединяется с ним стрелкой, ведущей в сторону базового класса (интерфейса).

Вершиной иерархии коллекций, а следовательно, самым общим типом, является интерфейс `Iterable`. Его свойства наследуют все коллекции библиотеки. Благодаря этому интерфейсу нам доступен в Java код следующего вида

[source,java]
----
    public static void foo(Iterable<String> container) {
        for (String element: container) { 
            bar(element)
        }
    }
----

На месте `Iterable` здесь может стоять `Collection`, `List`, `Set`, `Queue` и цикл for-each всё равно будет для них доступен. Интерфейс `Iterable` тесно связан с интерфейсом-помощником `Iterator` (так говорят в ситуации, когда помощник является бессмысленным без основного интерфейса, и наоборот). Его формальное описание выглядит так:

[source,java]
----
public interface Iterable<E> {
    Iterator<E> iterator(); // то есть Iterable даёт возможность получить Iterator
}
----

`Iterator` является чем-то вроде указателя, путешествующего по коллекции. В момент создания он "смотрит" перед нулевым элементом коллекции. Итератор содержит три метода:

[source,java]
----
public interface Iterator<E> {
    boolean hasNext(); // Возвращает true, если за итератором есть ещё элементы
    E next(); // Возвращает следующий элемент за итератором И передвигает итератор за него
    void remove(); // Удаляет из коллекции элемент, который вернул последний вызов next
}
----
